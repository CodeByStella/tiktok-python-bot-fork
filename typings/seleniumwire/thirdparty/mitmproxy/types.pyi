"""
This type stub file was generated by pyright.
"""

import typing
from seleniumwire.thirdparty.mitmproxy import CommandManager, flow

if typing.TYPE_CHECKING:
    ...
class Path(str):
    ...


class Cmd(str):
    ...


class CmdArgs(str):
    ...


class Unknown(str):
    ...


class Space(str):
    ...


class CutSpec(typing.Sequence[str]):
    ...


class Data(typing.Sequence[typing.Sequence[typing.Union[str, bytes]]]):
    ...


class Choice:
    def __init__(self, options_command) -> None:
        ...
    
    def __instancecheck__(self, instance): # -> Literal[False]:
        ...
    


class _BaseType:
    typ: typing.Type = ...
    display: str = ...
    def completion(self, manager: CommandManager, t: typing.Any, s: str) -> typing.Sequence[str]:
        """
            Returns a list of completion strings for a given prefix. The strings
            returned don't necessarily need to be suffixes of the prefix, since
            completers will do prefix filtering themselves..
        """
        ...
    
    def parse(self, manager: CommandManager, typ: typing.Any, s: str) -> typing.Any:
        """
            Parse a string, given the specific type instance (to allow rich type annotations like Choice) and a string.

            Raises exceptions.TypeError if the value is invalid.
        """
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        """
            Check if data is valid for this type.
        """
        ...
    


class _BoolType(_BaseType):
    typ = bool
    display = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> bool:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _StrType(_BaseType):
    typ = str
    display = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> str:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _UnknownType(_BaseType):
    typ = Unknown
    display = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> str:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _IntType(_BaseType):
    typ = int
    display = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> int:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _PathType(_BaseType):
    typ = Path
    display = ...
    def completion(self, manager: CommandManager, t: type, start: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> str:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _CmdType(_BaseType):
    typ = Cmd
    display = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> str:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _ArgType(_BaseType):
    typ = CmdArgs
    display = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> str:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _StrSeqType(_BaseType):
    typ = typing.Sequence[str]
    display = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _CutSpecType(_BaseType):
    typ = CutSpec
    display = ...
    valid_prefixes = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> CutSpec:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _BaseFlowType(_BaseType):
    viewmarkers = ...
    valid_prefixes = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    


class _FlowType(_BaseFlowType):
    typ = flow.Flow
    display = ...
    def parse(self, manager: CommandManager, t: type, s: str) -> flow.Flow:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _FlowsType(_BaseFlowType):
    typ = typing.Sequence[flow.Flow]
    display = ...
    def parse(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[flow.Flow]:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _DataType(_BaseType):
    typ = Data
    display = ...
    def completion(self, manager: CommandManager, t: type, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: type, s: str) -> typing.Any:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class _ChoiceType(_BaseType):
    typ = Choice
    display = ...
    def completion(self, manager: CommandManager, t: Choice, s: str) -> typing.Sequence[str]:
        ...
    
    def parse(self, manager: CommandManager, t: Choice, s: str) -> str:
        ...
    
    def is_valid(self, manager: CommandManager, typ: typing.Any, val: typing.Any) -> bool:
        ...
    


class TypeManager:
    def __init__(self, *types) -> None:
        ...
    
    def get(self, t: typing.Optional[typing.Type], default=...) -> typing.Optional[_BaseType]:
        ...
    


CommandTypes = ...
