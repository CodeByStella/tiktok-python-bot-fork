"""
This type stub file was generated by pyright.
"""

import contextlib
import typing

def cut_traceback(tb, func_name):
    """
    Cut off a traceback at the function with the given name.
    The func_name's frame is excluded.

    Args:
        tb: traceback object, as returned by sys.exc_info()[2]
        func_name: function name

    Returns:
        Reduced traceback.
    """
    ...

@contextlib.contextmanager
def safecall(): # -> Generator[None, Any, None]:
    ...

class Loader:
    """
        A loader object is passed to the load() event when addons start up.
    """
    def __init__(self, master) -> None:
        ...
    
    def add_option(self, name: str, typespec: type, default: typing.Any, help: str, choices: typing.Optional[typing.Sequence[str]] = ...) -> None:
        """
            Add an option to mitmproxy.

            Help should be a single paragraph with no linebreaks - it will be
            reflowed by tools. Information on the data type should be omitted -
            it will be generated and added by tools as needed.
        """
        ...
    
    def add_command(self, path: str, func: typing.Callable) -> None:
        ...
    


def traverse(chain): # -> Generator[Any, Any, None]:
    """
        Recursively traverse an addon chain.
    """
    ...

class AddonManager:
    def __init__(self, master) -> None:
        ...
    
    def clear(self): # -> None:
        """
            Remove all addons.
        """
        ...
    
    def get(self, name):
        """
            Retrieve an addon by name. Addon names are equal to the .name
            attribute on the instance, or the lower case class name if that
            does not exist.
        """
        ...
    
    def register(self, addon):
        """
            Register an addon, call its load event, and then register all its
            sub-addons. This should be used by addons that dynamically manage
            addons.

            If the calling addon is already running, it should follow with
            running and configure events. Must be called within a current
            context.
        """
        ...
    
    def add(self, *addons): # -> None:
        """
            Add addons to the end of the chain, and run their load event.
            If any addon has sub-addons, they are registered.
        """
        ...
    
    def remove(self, addon): # -> None:
        """
            Remove an addon and all its sub-addons.

            If the addon is not in the chain - that is, if it's managed by a
            parent addon - it's the parent's responsibility to remove it from
            its own addons attribute.
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    async def handle_lifecycle(self, name, message): # -> None:
        """
            Handle a lifecycle event.
        """
        ...
    
    def invoke_addon(self, addon, name, *args, **kwargs): # -> None:
        """
            Invoke an event on an addon and all its children.
        """
        ...
    
    def trigger(self, name, *args, **kwargs): # -> None:
        """
            Trigger an event across all addons.
        """
        ...
    


