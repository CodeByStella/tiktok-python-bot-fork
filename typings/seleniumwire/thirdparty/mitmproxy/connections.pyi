"""
This type stub file was generated by pyright.
"""

from seleniumwire.thirdparty.mitmproxy import stateobject
from seleniumwire.thirdparty.mitmproxy.net import tcp

class ClientConnection(tcp.BaseHandler, stateobject.StateObject):
    """
    A client connection

    Attributes:
        address: Remote address
        tls_established: True if TLS is established, False otherwise
        clientcert: The TLS client certificate
        mitmcert: The MITM'ed TLS server certificate presented to the client
        timestamp_start: Connection start timestamp
        timestamp_tls_setup: TLS established timestamp
        timestamp_end: Connection end timestamp
        sni: Server Name Indication sent by client during the TLS handshake
        cipher_name: The current used cipher
        alpn_proto_negotiated: The negotiated application protocol
        tls_version: TLS version
        tls_extensions: TLS ClientHello extensions
    """
    def __init__(self, client_connection, address, server) -> None:
        ...
    
    def connected(self): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    _stateobject_attributes = ...
    def send(self, message): # -> None:
        ...
    
    @classmethod
    def from_state(cls, state): # -> Self:
        ...
    
    @classmethod
    def make_dummy(cls, address): # -> Self:
        ...
    
    def convert_to_tls(self, cert, *args, **kwargs): # -> None:
        ...
    
    def finish(self): # -> None:
        ...
    


class ServerConnection(tcp.TCPClient, stateobject.StateObject):
    """
    A server connection

    Attributes:
        address: Remote address. Can be both a domain or an IP address.
        ip_address: Resolved remote IP address.
        source_address: Local IP address or client's source IP address.
        tls_established: True if TLS is established, False otherwise
        cert: The certificate presented by the remote during the TLS handshake
        sni: Server Name Indication sent by the mitmproxy during the TLS handshake
        alpn_proto_negotiated: The negotiated application protocol
        tls_version: TLS version
        via: The underlying server connection (e.g. the connection to the upstream mitmproxy in upstream mitmproxy mode)
        timestamp_start: Connection start timestamp
        timestamp_tcp_setup: TCP ACK received timestamp
        timestamp_tls_setup: TLS established timestamp
        timestamp_end: Connection end timestamp
    """
    def __init__(self, address, source_address=..., spoof_source_address=...) -> None:
        ...
    
    def connected(self): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    _stateobject_attributes = ...
    @classmethod
    def from_state(cls, state): # -> Self:
        ...
    
    @classmethod
    def make_dummy(cls, address): # -> Self:
        ...
    
    def connect(self): # -> None:
        ...
    
    def send(self, message): # -> None:
        ...
    
    def establish_tls(self, *, sni=..., client_certs=..., **kwargs): # -> None:
        ...
    
    def finish(self): # -> None:
        ...
    


class SocksServerConnection(ServerConnection):
    def __init__(self, socks_config, *args, **kwargs) -> None:
        ...
    
    def getaddrinfo(self, host, port, *args, **kwargs): # -> list[tuple[AddressFamily, SocketKind, int, str, tuple[Any, Any]]] | list[tuple[AddressFamily, SocketKind, int, str, tuple[str, int] | tuple[str, int, int, int] | tuple[int, bytes]]]:
        ...
    
    def makesocket(self, family, type, proto): # -> socksocket:
        ...
    


