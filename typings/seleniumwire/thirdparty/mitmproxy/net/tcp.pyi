"""
This type stub file was generated by pyright.
"""

import socket
from typing import Optional
from seleniumwire.thirdparty.mitmproxy import exceptions

socket_fileobject = socket.SocketIO
IPPROTO_IPV6 = ...
class _FileLike:
    BLOCKSIZE = ...
    def __init__(self, o) -> None:
        ...
    
    def set_descriptor(self, o): # -> None:
        ...
    
    def __getattr__(self, attr): # -> Any:
        ...
    
    def start_log(self): # -> None:
        """
            Starts or resets the log.

            This will store all bytes read or written.
        """
        ...
    
    def stop_log(self): # -> None:
        """
            Stops the log.
        """
        ...
    
    def is_logging(self): # -> bool:
        ...
    
    def get_log(self): # -> bytes:
        """
            Returns the log as a string.
        """
        ...
    
    def add_log(self, v): # -> None:
        ...
    
    def reset_timestamps(self): # -> None:
        ...
    


class Writer(_FileLike):
    def flush(self): # -> None:
        """
            May raise exceptions.TcpDisconnect
        """
        ...
    
    def write(self, v): # -> None:
        """
            May raise exceptions.TcpDisconnect
        """
        ...
    


class Reader(_FileLike):
    def read(self, length): # -> Literal[b""]:
        """
            If length is -1, we read until connection closes.
        """
        ...
    
    def readline(self, size=...): # -> Literal[b""]:
        ...
    
    def safe_read(self, length): # -> Literal[b""]:
        """
            Like .read, but is guaranteed to either return length bytes, or
            raise an exception.
        """
        ...
    
    def peek(self, length): # -> bytes:
        """
        Tries to peek into the underlying file object.

        Returns:
            Up to the next N bytes if peeking is successful.

        Raises:
            exceptions.TcpException if there was an error with the socket
            TlsException if there was an error with pyOpenSSL.
            NotImplementedError if the underlying file object is not a [pyOpenSSL] socket
        """
        ...
    


def ssl_read_select(rlist, timeout): # -> list[Connection] | list[Any]:
    """
    This is a wrapper around select.select() which also works for SSL.Connections
    by taking ssl_connection.pending() into account.

    Caveats:
        If .pending() > 0 for any of the connections in rlist, we avoid the select syscall
        and **will not include any other connections which may or may not be ready**.

    Args:
        rlist: wait until ready for reading

    Returns:
        subset of rlist which is ready for reading.
    """
    ...

def close_socket(sock): # -> None:
    """
    Does a hard close of a socket, without emitting a RST.
    """
    ...

class _Connection:
    rbufsize = ...
    wbufsize = ...
    def __init__(self, connection) -> None:
        ...
    
    def get_current_cipher(self): # -> tuple[Any, Any, Any] | None:
        ...
    
    def finish(self): # -> None:
        ...
    


class ConnectionCloser:
    def __init__(self, conn) -> None:
        ...
    
    def pop(self): # -> ConnectionCloser:
        """
            Cancel the current closer, and return a fresh one.
        """
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    


class TCPClient(_Connection):
    def __init__(self, address, source_address=..., spoof_source_address=...) -> None:
        ...
    
    @property
    def ssl_verification_error(self) -> Optional[exceptions.InvalidCertificateException]:
        ...
    
    def close(self): # -> None:
        ...
    
    def convert_to_tls(self, sni=..., alpn_protos=..., **sslctx_kwargs): # -> None:
        ...
    
    def makesocket(self, family, type, proto): # -> socket:
        ...
    
    def getaddrinfo(self, *args, **kwargs): # -> list[tuple[AddressFamily, SocketKind, int, str, tuple[str, int] | tuple[str, int, int, int] | tuple[int, bytes]]]:
        ...
    
    def create_connection(self, timeout=...): # -> socket:
        ...
    
    def connect(self): # -> ConnectionCloser:
        ...
    
    def settimeout(self, n): # -> None:
        ...
    
    def gettimeout(self): # -> float | Any | None:
        ...
    
    def get_alpn_proto_negotiated(self): # -> bytes:
        ...
    


def do_ssl_handshake(sock, ssl_connection): # -> None:
    """Peform the SSL handshake.

    If a timeout has been set on the socket externally, it causes OpenSSL
    to raise EWOULDBLOCK which breaks the handshake. This function will
    catch that condition and will retry the operation until it succeeds or
    some other error occurs.

    See https://github.com/pyca/pyopenssl/issues/168 for more information.

    Args:
        sock: The underlying socket.
        ssl_connection: The OpenSSL Connection object.
    """
    ...

class BaseHandler(_Connection):
    """
        The instantiator is expected to call the handle() and finish() methods.
    """
    def __init__(self, connection, address, server) -> None:
        ...
    
    def convert_to_tls(self, cert, key, **sslctx_kwargs): # -> None:
        """
        Convert connection to SSL.
        For a list of parameters, see tls.create_server_context(...)
        """
        ...
    
    def handle(self):
        ...
    
    def settimeout(self, n): # -> None:
        ...
    
    def get_alpn_proto_negotiated(self): # -> bytes:
        ...
    


class Counter:
    def __init__(self) -> None:
        ...
    
    @property
    def count(self): # -> int:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    


class TCPServer:
    def __init__(self, address) -> None:
        ...
    
    def connection_thread(self, connection, client_address): # -> None:
        ...
    
    def serve_forever(self, poll_interval=...): # -> None:
        ...
    
    def shutdown(self): # -> None:
        ...
    
    def handle_error(self, connection_, client_address, fp=...): # -> None:
        """
            Called when handle_client_connection raises an exception.
        """
        ...
    
    def handle_client_connection(self, conn, client_address):
        """
            Called after client connection.
        """
        ...
    
    def handle_shutdown(self): # -> None:
        """
            Called after server shutdown.
        """
        ...
    
    def wait_for_silence(self, timeout=...): # -> None:
        ...
    


