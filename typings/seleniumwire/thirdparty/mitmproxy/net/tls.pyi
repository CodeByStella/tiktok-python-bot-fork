"""
This type stub file was generated by pyright.
"""

import typing
import seleniumwire.thirdparty.mitmproxy.options
from OpenSSL import SSL
from seleniumwire.thirdparty.mitmproxy import certs

BASIC_OPTIONS = ...
if hasattr(SSL, "OP_NO_COMPRESSION"):
    ...
DEFAULT_METHOD = ...
DEFAULT_OPTIONS = ...
VERSION_CHOICES = ...
METHOD_NAMES = ...
def client_arguments_from_options(options: seleniumwire.thirdparty.mitmproxy.options.Options) -> dict:
    ...

class MasterSecretLogger:
    def __init__(self, filename) -> None:
        ...
    
    __name__ = ...
    def __call__(self, connection, where, ret): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    @staticmethod
    def create_logfun(filename): # -> MasterSecretLogger | None:
        ...
    


log_master_secret = ...
def create_client_context(cert: str = ..., sni: str = ..., address: str = ..., verify: int = ..., **sslctx_kwargs) -> SSL.Context:
    """
    Args:
        cert: Path to a file containing both client cert and private key.
        sni: Server Name Indication. Required for VERIFY_PEER
        address: server address, used for expressive error messages only
        verify: A bit field consisting of OpenSSL.SSL.VERIFY_* values
    """
    ...

def accept_all(conn_: SSL.Connection, x509: SSL.X509, errno: int, err_depth: int, is_cert_verified: bool) -> bool:
    ...

def create_server_context(cert: typing.Union[certs.Cert, str], key: SSL.PKey, handle_sni: typing.Optional[typing.Callable[[SSL.Connection], None]] = ..., request_client_cert: bool = ..., chain_file=..., dhparams=..., extra_chain_certs: typing.Iterable[certs.Cert] = ..., **sslctx_kwargs) -> SSL.Context:
    """
        cert: A certs.Cert object or the path to a certificate
        chain file.

        handle_sni: SNI handler, should take a connection object. Server
        name can be retrieved like this:

                connection.get_servername()

        The request_client_cert argument requires some explanation. We're
        supposed to be able to do this with no negative effects - if the
        client has no cert to present, we're notified and proceed as usual.
        Unfortunately, Android seems to have a bug (tested on 4.2.2) - when
        an Android client is asked to present a certificate it does not
        have, it hangs up, which is frankly bogus. Some time down the track
        we may be able to make the proper behaviour the default again, but
        until then we're conservative.
    """
    ...

def is_tls_record_magic(d): # -> Literal[False]:
    """
    Returns:
        True, if the passed bytes start with the TLS record magic bytes.
        False, otherwise.
    """
    ...

def get_client_hello(rfile): # -> Literal[b""]:
    """
    Peek into the socket and read all records that contain the initial client hello message.

    client_conn:
        The :py:class:`client connection <seleniumwire.thirdparty.mitmproxy.connections.ClientConnection>`.

    Returns:
        The raw handshake packet bytes, without TLS record header(s).
    """
    ...

class ClientHello:
    def __init__(self, raw_client_hello) -> None:
        ...
    
    @property
    def cipher_suites(self):
        ...
    
    @property
    def sni(self) -> typing.Optional[bytes]:
        ...
    
    @property
    def alpn_protocols(self): # -> list[Any]:
        ...
    
    @property
    def extensions(self) -> typing.List[typing.Tuple[int, bytes]]:
        ...
    
    @classmethod
    def from_file(cls, client_conn) -> ClientHello:
        """
        Peek into the connection, read the initial client hello and parse it to obtain ALPN values.
        client_conn:
            The :py:class:`client connection <seleniumwire.thirdparty.mitmproxy.connections.ClientConnection>`.
        Returns:
            :py:class:`client hello <seleniumwire.thirdparty.mitmproxy.net.tls.ClientHello>`.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


