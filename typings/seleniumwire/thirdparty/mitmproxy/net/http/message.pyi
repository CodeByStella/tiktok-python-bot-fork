"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Callable, Optional, Union
from seleniumwire.thirdparty.mitmproxy.coretypes import serializable
from seleniumwire.thirdparty.mitmproxy.net.http.headers import Headers

@dataclass
class MessageData(serializable.Serializable):
    http_version: bytes
    headers: Headers
    content: Optional[bytes]
    trailers: Optional[Headers]
    timestamp_start: float
    timestamp_end: Optional[float]
    if __debug__:
        def __post_init__(self): # -> None:
            ...
        
    def set_state(self, state): # -> None:
        ...
    
    def get_state(self): # -> dict[str, Any]:
        ...
    
    @classmethod
    def from_state(cls, state): # -> Self:
        ...
    


class Message(serializable.Serializable):
    @classmethod
    def from_state(cls, state): # -> Self:
        ...
    
    def get_state(self): # -> dict[str, Any]:
        ...
    
    def set_state(self, state): # -> None:
        ...
    
    data: MessageData
    stream: Union[Callable, bool] = ...
    @property
    def http_version(self) -> str:
        """
        Version string, e.g. "HTTP/1.1"
        """
        ...
    
    @http_version.setter
    def http_version(self, http_version: Union[str, bytes]) -> None:
        ...
    
    @property
    def is_http10(self) -> bool:
        ...
    
    @property
    def is_http11(self) -> bool:
        ...
    
    @property
    def is_http2(self) -> bool:
        ...
    
    @property
    def headers(self) -> Headers:
        """
        The HTTP headers.
        """
        ...
    
    @headers.setter
    def headers(self, h: Headers) -> None:
        ...
    
    @property
    def trailers(self) -> Optional[Headers]:
        """
        The HTTP trailers.
        """
        ...
    
    @trailers.setter
    def trailers(self, h: Optional[Headers]) -> None:
        ...
    
    @property
    def raw_content(self) -> Optional[bytes]:
        """
        The raw (potentially compressed) HTTP message body as bytes.

        See also: :py:attr:`content`, :py:class:`text`
        """
        ...
    
    @raw_content.setter
    def raw_content(self, content: Optional[bytes]) -> None:
        ...
    
    def get_content(self, strict: bool = ...) -> Optional[bytes]:
        """
        The uncompressed HTTP message body as bytes.

        Raises:
            ValueError, when the HTTP content-encoding is invalid and strict is True.

        See also: :py:class:`raw_content`, :py:attr:`text`
        """
        ...
    
    def set_content(self, value: Optional[bytes]) -> None:
        ...
    
    content = ...
    @property
    def timestamp_start(self) -> float:
        """
        First byte timestamp
        """
        ...
    
    @timestamp_start.setter
    def timestamp_start(self, timestamp_start: float) -> None:
        ...
    
    @property
    def timestamp_end(self) -> Optional[float]:
        """
        Last byte timestamp
        """
        ...
    
    @timestamp_end.setter
    def timestamp_end(self, timestamp_end: Optional[float]): # -> None:
        ...
    
    def get_text(self, strict: bool = ...) -> Optional[str]:
        """
        The uncompressed and decoded HTTP message body as text.

        Raises:
            ValueError, when either content-encoding or charset is invalid and strict is True.

        See also: :py:attr:`content`, :py:class:`raw_content`
        """
        ...
    
    def set_text(self, text: Optional[str]) -> None:
        ...
    
    text = ...
    def decode(self, strict: bool = ...) -> None:
        """
        Decodes body based on the current Content-Encoding header, then
        removes the header. If there is no Content-Encoding header, no
        action is taken.

        Raises:
            ValueError, when the content-encoding is invalid and strict is True.
        """
        ...
    
    def encode(self, e: str) -> None:
        """
        Encodes body with the encoding e, where e is "gzip", "deflate", "identity", "br", or "zstd".
        Any existing content-encodings are overwritten,
        the content is not decoded beforehand.

        Raises:
            ValueError, when the specified content-encoding is invalid.
        """
        ...
    


