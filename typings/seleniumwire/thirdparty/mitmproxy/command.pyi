"""
This type stub file was generated by pyright.
"""

import functools
import inspect
import typing

"""
    This module manages and invokes typed commands.
"""
def verify_arg_signature(f: typing.Callable, args: typing.Iterable[typing.Any], kwargs: dict) -> None:
    ...

def typename(t: type) -> str:
    """
        Translates a type to an explanatory string.
    """
    ...

class CommandParameter(typing.NamedTuple):
    name: str
    type: typing.Type
    kind: inspect._ParameterKind = ...
    def __str__(self) -> str:
        ...
    


class Command:
    name: str
    manager: CommandManager
    signature: inspect.Signature
    help: typing.Optional[str]
    def __init__(self, manager: CommandManager, name: str, func: typing.Callable) -> None:
        ...
    
    @property
    def return_type(self) -> typing.Optional[typing.Type]:
        ...
    
    @property
    def parameters(self) -> typing.List[CommandParameter]:
        """Returns a list of CommandParameters."""
        ...
    
    def signature_help(self) -> str:
        ...
    
    def prepare_args(self, args: typing.Sequence[str]) -> inspect.BoundArguments:
        ...
    
    def call(self, args: typing.Sequence[str]) -> typing.Any:
        """
        Call the command with a list of arguments. At this point, all
        arguments are strings.
        """
        ...
    


class ParseResult(typing.NamedTuple):
    value: str
    type: typing.Type
    valid: bool
    ...


class CommandManager:
    commands: typing.Dict[str, Command]
    def __init__(self, master) -> None:
        ...
    
    def collect_commands(self, addon): # -> None:
        ...
    
    def add(self, path: str, func: typing.Callable): # -> None:
        ...
    
    @functools.lru_cache(maxsize=128)
    def parse_partial(self, cmdstr: str) -> typing.Tuple[typing.Sequence[ParseResult], typing.Sequence[CommandParameter]]:
        """
        Parse a possibly partial command. Return a sequence of ParseResults and a sequence of remainder type help items.
        """
        ...
    
    def call(self, command_name: str, *args: typing.Sequence[typing.Any]) -> typing.Any:
        """
        Call a command with native arguments. May raise CommandError.
        """
        ...
    
    def call_strings(self, command_name: str, args: typing.Sequence[str]) -> typing.Any:
        """
        Call a command using a list of string arguments. May raise CommandError.
        """
        ...
    
    def execute(self, cmdstr: str) -> typing.Any:
        """
        Execute a command string. May raise CommandError.
        """
        ...
    
    def dump(self, out=...) -> None:
        ...
    


def parsearg(manager: CommandManager, spec: str, argtype: type) -> typing.Any:
    """
        Convert a string to a argument to the appropriate type.
    """
    ...

def command(name: typing.Optional[str] = ...): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    ...

def argument(name, type): # -> Callable[..., FunctionType]:
    """
        Set the type of a command argument at runtime. This is useful for more
        specific types such as seleniumwire.thirdparty.mitmproxy.types.Choice, which we cannot annotate
        directly as mypy does not like that.
    """
    ...

