"""
This type stub file was generated by pyright.
"""

import enum
from seleniumwire.thirdparty.mitmproxy.server.protocol import base

log = ...
class _HttpTransmissionLayer(base.Layer):
    def read_request_headers(self, flow):
        ...
    
    def read_request_body(self, request):
        ...
    
    def read_request_trailers(self, request):
        ...
    
    def send_request(self, request):
        ...
    
    def read_response_headers(self):
        ...
    
    def read_response_body(self, request, response): # -> Generator[Never, Any, Any]:
        ...
    
    def read_response_trailers(self, request, response):
        ...
    
    def read_response(self, request):
        ...
    
    def send_response(self, response): # -> None:
        ...
    
    def send_response_headers(self, response):
        ...
    
    def send_response_body(self, response, chunks):
        ...
    
    def send_response_trailers(self, response, chunks):
        ...
    
    def check_close_connection(self, f):
        ...
    


class ConnectServerConnection:
    """
    "Fake" ServerConnection to represent state after a CONNECT request to an upstream mitmproxy.
    """
    def __init__(self, address, ctx) -> None:
        ...
    
    @property
    def via(self):
        ...
    
    def __getattr__(self, item): # -> Any:
        ...
    
    def connected(self):
        ...
    


class UpstreamConnectLayer(base.Layer):
    def __init__(self, ctx, connect_request) -> None:
        ...
    
    def __call__(self): # -> None:
        ...
    
    def connect(self): # -> None:
        ...
    
    def change_upstream_proxy_server(self, address): # -> None:
        ...
    
    def set_server(self, address): # -> None:
        ...
    


def is_ok(status):
    ...

class HTTPMode(enum.Enum):
    regular = ...
    transparent = ...
    upstream = ...


MODE_REQUEST_FORMS = ...
def validate_request_form(mode, request): # -> None:
    ...

class HttpLayer(base.Layer):
    if False:
        ...
    def __init__(self, ctx, mode) -> None:
        ...
    
    def __call__(self): # -> None:
        ...
    
    def handle_regular_connect(self, f): # -> Literal[False]:
        ...
    
    def handle_upstream_connect(self, f): # -> Literal[False] | None:
        ...
    
    def send_error_response(self, code, message, headers=...) -> None:
        ...
    
    def change_upstream_proxy_server(self, address): # -> None:
        ...
    
    def establish_server_connection(self, host: str, port: int, scheme: str): # -> None:
        ...
    
    def should_bypass_upstream_proxy(self, request): # -> bool:
        """Whether we should bypass any upstream proxy.

        This checks whether the request address is in the no_proxy list.
        """
        ...
    
    def apply_proxy_auth(self, f): # -> None:
        """Apply proxy authorization to the request if configured."""
        ...
    


