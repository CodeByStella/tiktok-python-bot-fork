"""
This type stub file was generated by pyright.
"""

from typing import Dict, NamedTuple

log = ...
ROOT_CERT = ...
ROOT_KEY = ...
COMBINED_CERT = ...
MITM_MODE = ...
MITM_UPSTREAM_AUTH = ...
MITM_UPSTREAM_CUSTOM_AUTH = ...
MITM_NO_PROXY = ...
def get_upstream_proxy(options): # -> dict[Any, Any]:
    """Get the upstream proxy configuration from the options dictionary.
    This will be overridden with any configuration found in the environment
    variables HTTP_PROXY, HTTPS_PROXY, NO_PROXY

    The configuration will be returned as a dictionary with keys 'http',
    'https' and 'no_proxy'. The value of the 'http' and 'https' keys will
    be a named tuple with the attributes:
        scheme, username, password, hostport
    The value of 'no_proxy' will be a list.

    Note that the keys will only be present in the dictionary when relevant
    proxy configuration exists.

    Args:
        options: The selenium wire options.
    Returns: A dictionary.
    """
    ...

def build_proxy_args(proxy_config: Dict[str, NamedTuple]) -> Dict[str, str]:
    """Build the arguments needed to pass an upstream proxy to mitmproxy.

    Args:
        proxy_config: The proxy config parsed out of the Selenium Wire options.
    Returns: A dictionary of arguments suitable for passing to mitmproxy.
    """
    ...

def extract_cert(cert_name=...): # -> None:
    """Extracts the root certificate to the current working directory."""
    ...

def extract_cert_and_key(dest_folder, cert_path=..., key_path=..., check_exists=...): # -> None:
    """Extracts the root certificate and key and combines them into a
    single file called seleniumwire-ca.pem in the specified destination
    folder.

    Args:
        dest_folder: The destination folder that the combined certificate
            and key will be written to.
        cert_path: Optional path to the root certificate. When not supplied
            selenium wire's own root certificate will be used.
        key_path: Optional path to the private key. When not supplied
            selenium wire's own private key will be used. Note that the key
            must always be supplied when a certificate is supplied.
        check_exists: If True the combined file will not be overwritten
            if it already exists in the destination folder.
    """
    ...

def is_list_alike(container): # -> bool:
    ...

def urlsafe_address(address): # -> tuple[str | Any, Any]:
    """Make an address safe to use in a URL.

    Args:
        address: A tuple of address information.
    Returns:
        A 2-tuple of url-safe (address, port)
    """
    ...

def decode(data: bytes, encoding: str) -> bytes:
    """Attempt to decode data based on the supplied encoding.

    If decoding fails a ValueError is raised.

    Args:
        data: The encoded data.
        encoding: The encoding type.
    Returns: The decoded data.
    Raises: ValueError if the data could not be decoded.
    """
    ...

